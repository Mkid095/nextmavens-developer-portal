# Database Migrations

This directory contains SQL migration files for the NextMavens Developer Platform database.

## Naming Convention

Migrations follow the pattern: `NNN_description.sql`

- `NNN` - Three-digit sequence number (001, 002, 003, etc.)
- `description` - Short, descriptive name in snake_case

Examples:
- `001_initial_schema_migrations.sql`
- `002_create_request_traces_table.sql`
- `003_create_organizations_table.sql`

## Migration File Format

Each migration file should include:

```sql
-- Migration: Short description of what this migration does
-- Description: More detailed explanation (optional)
-- Version: NNN
-- Breaking: true/false (optional, defaults to false)
-- Rollback: SQL statement to rollback this migration (optional)

-- Your migration SQL here

-- Insert migration record (optional - auto-generated by runner)
-- INSERT INTO control_plane.schema_migrations (version, description, breaking)
-- VALUES ('NNN', 'Your description', FALSE);
```

### Supported Migration Metadata

- `-- Breaking: true` - Mark this as a breaking change that requires special attention
- `-- Rollback: DROP TABLE ...;` - Provide SQL to rollback this migration

## Running Migrations

Migrations are executed automatically by the migration runner in `src/lib/migrations.ts`.

### Programmatic Usage

```typescript
import { runMigrations, getMigrationStatus, rollbackMigration, getMigrationPlan } from './lib/migrations'

// Run all pending migrations
await runMigrations()

// US-007: Dry run - show what migrations would be applied without actually running them
await runMigrations({ dryRun: true })

// US-007: Verbose dry run with more details
await runMigrations({ dryRun: true, verbose: true })

// Check migration status
const status = await getMigrationStatus()
console.log('Applied:', status.applied)
console.log('Pending:', status.pending)

// US-007: Get migration plan programmatically
const plan = await getMigrationPlan()
console.log('Pending migrations:', plan)

// Rollback a specific migration (if rollback SQL is provided)
await rollbackMigration('002')
```

### Testing Migrations on Staging (US-007)

**Before running migrations in production, always test on staging first.**

Use the dry-run mode to preview what migrations will be applied:

```typescript
// Preview pending migrations
await runMigrations({ dryRun: true, verbose: true })
```

This will show:
- Which migrations are pending
- What each migration does (description)
- The impact of each migration (tables created, schema changes, etc.)
- Whether any migrations are breaking changes
- The rollback SQL (if available)

Process for testing migrations:
1. Run dry-run on staging: `await runMigrations({ dryRun: true, verbose: true })`
2. Review the output carefully
3. Apply migrations on staging: `await runMigrations({ environment: 'staging' })`
4. Test your application against the staging database
5. If everything works, apply to production: `await runMigrations({ environment: 'production' })`

## Transaction Handling

Each migration runs in its own transaction. If a migration fails:
- Only that migration is rolled back
- Previously applied migrations remain applied
- The migration runner stops and reports the error

## Migration Tracking

All migrations are tracked in the `control_plane.schema_migrations` table:

| Column | Type | Description |
|--------|------|-------------|
| version | VARCHAR(50) | Migration version number |
| description | TEXT | Description of what the migration does |
| applied_at | TIMESTAMPTZ | When the migration was applied |
| rollback_sql | TEXT | SQL to rollback this migration (optional) |
| breaking | BOOLEAN | Whether this is a breaking change |
| created_at | TIMESTAMPTZ | When the migration record was created |

## Best Practices

1. **Always use `IF NOT EXISTS`** when creating tables, indexes, etc. to make migrations idempotent
2. **Test migrations** on a staging environment before production
3. **Provide rollback SQL** for destructive operations
4. **Mark breaking changes** with `-- Breaking: true`
5. **Keep migrations focused** - one logical change per file
6. **Never modify existing migrations** - always create a new one

## Rollback Strategy

Not all migrations can be rolled back. When writing rollback SQL:

- Test the rollback SQL thoroughly
- Consider data loss implications
- Document any manual steps required
- For complex migrations, consider creating a new forward migration instead

## Breaking Changes

Breaking changes are those that:
- Drop or rename tables/columns
- Change data types in incompatible ways
- Remove or modify indexes that queries depend on
- Change constraints in ways that break existing code

Breaking changes are marked in the `schema_migrations` table and the migration runner warns before applying them in production environments.
